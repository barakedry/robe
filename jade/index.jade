include ./_mixins

doctype html
html
  head
    meta(charset="utf-8")
    meta(http-equiv="X-UA-Compatible", content="chrome=1")
    meta(name="keywords", content="javascript,nodejs,odm,mongodb,github,es6")
    meta(name="description", content="Node.js ODM for MongoDB using ES6 generators.")
    meta(name="viewport", content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=0")
    meta(name="apple-mobile-web-app-capable", content="yes")
    meta(name="apple-mobile-web-app-status-bar-style", content="default")
    title Robe
    link(href='https://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic', rel='stylesheet', type='text/css')
    link(href='https://fonts.googleapis.com/css?family=Bree+Serif', rel='stylesheet', type='text/css')
    link(href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css", rel="stylesheet")
    link(href="css/prism.css", rel="stylesheet", type='text/css')
    link(href="css/style.css", rel="stylesheet", type='text/css')
    script(src="js/scale.fix.js")
  body
    header
      h2 Robe
      nav
      .links
        a.github(href="https://github.com/hiddentao/robe")
          i.fa.fa-github
          span Github
        a.twitter(href="https://twitter.com/hiddentao")
          i.fa.fa-twitter
          span Twitter
    main
      h1
        span Robe
        small Node.js ODM for MongoDB using ES6 generators

      +code('bash').
        $ npm install --save robe

      a.github(href="https://github.com/hiddentao/robe", title="View on Github")
        i.fa.fa-github
        span View on Github

      section#intro
        :markdown
          **Robe** wraps around [monk](https://github.com/Automattic/monk) to provide a 
          simple ODM library for MongoDB. 

          Overview:

          * ES6 - **no callbacks needed**.
          * Supports standard Mongo [query modifiers](#querying).
          * Connect to [hosts and replica sets](#connecting).
          * Use [documents](#documents) or [raw data](#raw), your choice.
          * Add [hooks](#hooks) for further processing.
          * Stream results using [cursors](#cursors).
          * Add [schema validation](#schema) and [custom methods](#custom_methods).
          * Notifications via [mongo oplog tailing](#oplog).
          * Clean, object-oriented [API](#api).

          To use Robe within your code:

        +code('javascript').
          "use strict";

          var Robe = require('robe');

      section#connecting
        :markdown
          ## Connecting

          Robe supports multiple independent database connections:

        +code('javascript').
          var db1 = yield Robe.connect('127.0.0.1'),
            db2 = yield Robe.connect('127.2.1.1');

        :markdown
            The returned object is an instance of `Robe.Database`.

            Replica sets are also supported:

        +code('javascript').
          var db = yield Robe.connect(['127.0.0.1/db-name', '127.2.3.23']);

      section#querying
        :markdown
          ## Querying

          Imagine we have a sample collection - **students** - with the 
          following data:

        table
          thead
            tr
              th _id
              th name
              th score
          tr
            td 1
            td Tom
            td 19            
          tr
            td 2
            td Jim
            td 22            
          tr
            td 3
            td Abe
            td 98            
          tr
            td 4
            td Candy
            td 5            
          tr
            td 5
            td Ram
            td 27            
          tr
            td 6
            td Drew
            td 41            
          tr
            td 7
            td Jeff
            td 31            

        :markdown
          To fetch results:

        +code('javascript').
          var collection = db.collection('students');

          var results = yield collection.find({
            // the filtering query (all Mongo modifiers supported)
            score: {
              $gt: 20
            },
          }, {
            // only include certain fields in the results
            fields: ['name'],
            // sort results
            sort: { name: 1 },
            // limit no. of results to return
            limit: 3,
            // ignore the first N results
            skip: 1,
          });

          console.log(
            results.map(function(r) {
              return r.name;
            })
          );

          /* 'Drew', 'Jeff', 'Ram' */

        :markdown
          When you only need one result there is a shortcut method you can use:

        +code('javascript').
          var collection = db.collection('students');

          var result = yield collection.findOne({
            // the filtering query (all Mongo modifiers supported)
            score: {
              $gt: 20
            },
          }, {
            // only include certain fields in the results
            fields: ['name'],
            // sort results
            sort: { name: 1 },
            // ignore the first N results
            skip: 1,
          });

          console.log(result.name); 

          /* 'Drew' */

      section#documents
        :markdown
          ### Documents 

          Each returned result is an instance of `Robe.Document`. Documents 
          encapsulate the raw data and can be enumerated just like plain 
          objects:

        +code('javascript').
          var result = yield collection.findOne({
            // the filtering query (all Mongo modifiers supported)
            score: {
              $gt: 20
            },
          }, {
            // only include certain fields in the results
            fields: ['name'],
            // sort results
            sort: { name: 1 },
            // ignore the first N results
            skip: 1,
          });

          // output the raw data
          console.log( result.toJSON() );

          /*
            {
              _id: 6,
              name: 'Drew',
              score: 41
            }
           */

          // output document keys
          console.log( Object.keys(result) );

          /*
            '_id', 'name', 'score'
          */

         
        :markdown
          `Robe.Documents` instances automatically keep track of which 
          properties get changed and only update those properties in the 
          database when you call `save()`.

        +code('javascript').
          var result = yield collection.findOne({
            score: {
              $gt: 20
            },
          });

          result.name = 'Jimbo';

          yield result.save();

          /* 
          Same as calling:

          yield collection.update({_id: result._id}, {
            $set: {
              name: 'Jimbo'
            }
          });
          */
         
        :markdown
          When setting `Array` and `Object` properties of a `Robe.Document` you 
          may need to additionally call the `markChanged()` method to tell 
          Robe that that specific property got updated:

        +code('javascript').
          var result = yield collection.findOne({
            'location.city': 'NYC'
          });

          result.location.city = 'London';

          // we need to tell Robe that the 'location' key got updated
          result.markChanged('location');

          yield result.save();

          /* 
          Same as calling:

          yield collection.update({_id: result._id}, {
            $set: {
              location: {
                city: 'London'
              }
            }
          });
          */
           
      section#raw
        :markdown
          ### Raw data

          If you do wish to deal directly with Mongo data and not use 
          `Robe.Document` instances you can specify the `rawMode` option:

        +code('javascript').
          var results = yield collection.findOne({
            _id: 1
          }, {
            // return Mongo data objects rather than Document instances
            rawMode: true 
          });

          console.log( result instancoof Robe.Document ); // false

          console.log( result );

          /*
            {
              _id: 1,
              name: 'Tom',
              score: 19
            }
          */

        :markdown
          The `rawMode` option can be specified at the collection level so that 
          you don't have to keep specifying it for every query:

        +code('javascript').
          var collection = db.collection('students', {
            rawMode: true
          });

          var results = yield collection.findOne({  _id: 1 });

          console.log( result instancoof Robe.Document ); // false

      section#cursors
        :markdown
          ### Cursors (streaming)

          Sometimes it's useful to be able to stream data from the database 
          one document at a time, especially if we expect the result set to 
          be quite large and thus wish to process it bit-by-bit.

          Robe can give you an event-driven cursor to facilitate this:

          _Note: At the moment we use an event emitter (and thus, callbacks) when 
          working with cursors. We hope to use generators instead in future._

        +code('javascript').
          var cursor = yield collection.findStream({  
            score: {
              $gt: 20
            }
          }, {
            limit: 3,
            sort: {
              name: -1
            },
            fields: [ 'name' ],
          });


          cursor.on('result', function(doc) {
            console.log(doc instanceof Robe.Document);  // true
            console.log( doc.toJSON() );
          });

          cursor.on('error', function(err) {
            console.error(err);
          });

          cursor.on('success', function() {
            console.log('All done.');
          });

          /*
            {
              name: 'Tom'                
            }
            {
              name: 'Ram'                
            }
            {
              name: 'Jim'                
            }
            All done.
          */

      section#inserting
        :markdown
          ## Inserting

          Inserting data is done via the `Robe.Collection` instance:

        +code('javascript').
          var collection = db.collection('students');

          var item = yield collection.insert({
            name: 'Amanda',
            score: 76
          });

          console.log( item instanceof Robe.Document ); // true

          console.log( item.toJSON() );

          /*
            {
              _id: ...auto-generated mongo id...,
              name: 'Amanda',
              score: 76
            }  
          */
         
        :markdown
          Raw insertion mode is also supported:

        +code('javascript').
          var collection = db.collection('students');

          var item = yield collection.insert({
            name: 'Amanda',
            score: 76
          }, {
            raw: true
          });

          console.log( item instanceof Robe.Document ); // false

          console.log( item );

          /*
            {
              _id: ...auto-generated mongo id...,
              name: 'Amanda',
              score: 76
            }  
          */

      section#updating
        :markdown
          ## Updating

          Changes made to a `Robe.Document` can be saved:

        +code('javascript').
          var item = yield collection.findOne({
            _id: 1
          });

          item.name = 'Martha';

          yield item.save();

        :markdown
          Internally this method calls through to the collection:

        +code('javascript').
          yield collection.update({
            _id: 1  
          }, {
            $set: {
              name: 'Martha'
            }
          });

        :markdown
          When calling `update()` on the collection, ommitting `$set` will 
          cause the entire document to be overriden, just as you would expect:

        +code('javascript').
          yield collection.update({
            _id: 1  
          }, {
            name: 'Martha'
          });

      section#removing
        :markdown
          ## Removing

          Removing a document:

        +code('javascript').
          var item = yield collection.findOne({
            _id: 1
          });

          yield item.remove();

        :markdown
          Internally this method calls through to the collection:

        +code('javascript').
          yield collection.remove({
            _id: 1  
          });

      section#custom_methods
        :markdown
          ## Custom methods

          You can extend `Robe.Collection` instances with custom querying methods:

        +code('javascript').
          var collection = db.collection('students', {
            methods: {
              // Custom methods must be generator methods.
              findStudentsWithScoreAbove: function*(threshold) {
                // The 'this' context is automatically set to be the Collection instance
                return yield this.find({
                  score: {
                    $gt: threshold
                  }
                }, {
                  sort: {
                    score: 1
                  },
                  raw: true
                });
              }
            }
          });
  
          yield collection.findStudentsWithScoreAbove(40);

          /*
            [
              {
                _id: 3,
                name: 'Abe',
                score: 98
              },
              {
                _id: 6,
                name: 'Drew',
                score: 41
              }
            ]          
          */

      section#schema
        :markdown
          ## Schema validation

          Robe will validate the structure of your document against a schema you 
          provide:

        +code('javascript').
          var collection = db.collection('students', {
            schema: {
              name: {
                type: String
              },
              score: {
                type: Number,
                required: true
              }
            }
          });
  
          yield collection.insert({
            name: 23,
            hasKids: true  
          });

          /*
            Error: Validation failed
          */
         
        :markdown
          The thrown `Error` instance has a `failures` key which lists the 
          specific validation failures. For the previous example:

        +code('javascript').
          console.log( err.failures );

          /*
            [
              "/name: must be a string"
              "/score: missing value"
            ]
          */
         
        :markdown
          _Note: Although `hasKids` is present in the inserted document, since it 
          isn't present in the schema it gets ignored._

          Schema validation is done by 
          [simple-mongo-schema](https://github.com/hiddentao/simple-mongo-schema),
          allowing for nested hierarchies:

        +code('javascript').
          var collection = db.collection('students', {
            schema: {
              name: {
                type: String
              },
              address: {
                type: {
                  houseNum: {
                    type: Number,
                    required: true
                  },
                  streetName: {
                    type: String,
                    required: true
                  },
                  country: {
                    type: String,
                    required: true
                  }
                }
              }
            }
          });
  
          try {
            yield collection.insert({
              name: 23,
              address: {
                houseNum: 'view street',
                streetName: 23
              }
            });
          } catch (err) {
            console.log(err.failures);

            /*
              [ 
                "/address/houseNum: must be a number",
                "/address/streetName: must be a string",
                "/address/country: missing value",
              ]
            */
          }


      section#indexes
        :markdown
          ## Indexes

          Robe supports the full [MongoDB index specification](http://docs.mongodb.org/manual/reference/method/db.collection.ensureIndex/), 
          including compound, geospatial and other index types. Specify the 
          indexes when fetching a collection:

        +code('javascript').
          var collection = db.collection('students', {
            schema: {
              name: {
                type: String
              },
              score: {
                type: Number,
              }
            },
            indexes: [
              // single-field index, unique
              {
                fields: {
                  name: 1
                },
                options: {
                  unique: true
                }
              },
              // compount-field index, custom index name
              {
                fields: {
                  name: 1,
                  score: 1,
                },
                options: {
                  name: 'index2'
                }
              }
            ]
          });
  
          // Create the indexes if not already present. Throws Error if it fails.
          yield collection.ensureIndexes();
         
      section#hooks
        :markdown
          ## Hooks

          Hooks allow you to perform additional asynchronous processing upon 
          data before and/or after all inserts, updates and removals.

          You can register hooks against a `Robe.Collection` instance. 
          Hooks get triggered regardless of whether you call methods on the 
          collection or perform updates through a `Robe.Document` instance:

        +code('javascript').
          var collection = db.collection('students');

          // run before schema validation and insertion
          collection.before('insert', function*(attrs, next) {
            console.log('before');

            attrs.hasKids = true;

            yield next;
          });

          // run after successful insertion
          collection.after('insert', function*(result, next) {
            console.log('after');

            console.log(result);

            yield next;
          });

          collection.insert({
            name: 'Janice'
          });

          /*
            before
            after
            {
              _id: ...mongo id...,
              name: 'Janice',
              hasKids: true
            }  
          */

        :markdown
          Multiple handlers can be registerd for a given hook:

        +code('javascript').
          collection.before('remove', function*(search, next) {
            console.log('before 1');

            search._id += 5;

            yield next;
          });

          collection.before('remove', function*(search, next) {
            console.log('before 2');

            search._id += 1;

            yield next;
          });

          collection.before('remove', function*(search, result, next) {
            console.log('after: ' + result);

            console.log(search._id);

            yield next;
          });

          collection.remove({
            _id: 0
          });

          /*
            before 1
            before 2
            after: 1
            6
          */

        :markdown
          For updates you get passed the search query as well as the update 
          instructions:

        +code('javascript').
          collection.before('update', function*(search, update, next) {
            console.log('before 1');

            yield next;
          });

          collection.after('update', function*(search, update, result, next) {
            console.log('after 1');

            yield next;
          });

          collection.after('update', function*(search, update, result, next) {
            console.log('after 2');

            yield next;
          });

          collection.update({
            _id: 0
          }, {
            $set: {
              name: 'Devon'
            }
          });

          /*
            before 1
            after 1
            after 2
          */          

      section#oplog
        :markdown
          ## Oplog tailing

          If you connect to a Mongo replica set then Robe can notify you when 
          data within your collections gets updated by your client process or any other.

          This can be thought of as a pub/sub mechanism and is used to great 
          effect in _reactive_ framworks such as [Meteor](https://github.com/meteor/meteor/wiki/Oplog-Observe-Driver).

          To get started:

        +code('javascript').
          var collection = db.collection("students");

          // watch for any changes to the collection
          yield collection.addWatcher(function(collectionName, operationType, data) {
            // collectionName = collection which got updated ("student" in this case)
            // operationType = one of: "insert", "update", "delete"
            // data = the data which got inserted or updated (an object)
          });

        :markdown
          The internal oplog query cursor is not activated until you add a 
          watcher. To stop watching for changes:

        +code('javascript').
          var collection = db.collection("students");

          var callback = function() { // ... };

          // watch for any changes to the collection
          yield collection.addWatcher(callback);

          // stop watching
          yield collection.removeWatcher(callback);

        :markdown
          You can also access and use the oplog directly through the `Database` 
          object:

        +code('javascript').
          // get the oplog
          var oplog = yield db.oplog();

          // listen for any operation on any collection
          oplog.onAny(function(collectionName, operationType, data) {
            // ...
          });

          // listen for any operation on the "student" collection
          oplog.on('student:*', function(collectionName, operationType, data) {
            // ...
          });

          // listen for "insert" operations on the "student" collection
          oplog.on('student:insert', function(collectionName, operationType, data) {
            // ...
          });

        :markdown
          _Note: The current oplog tailing cursor implementation is naive and 
          does not take into account how Mongo chooses to populate the oplog. 
          Certain bulk operations MAY result in multiple 
          notifications being sent to the registered watchers._


      section#api
        h2 API
        


      footer
        p By <a href="https://twitter.com/hiddentao">@hiddentao</a>. Source on <a href="https://github.coom/hiddentao/robe">Github</a>.

    script(type="text/javascript", src="js/prism.js")
    script(type="text/javascript", src="js/jquery.js")
    script(type="text/javascript", src="js/main.js")      