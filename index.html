<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><meta name="keywords" content="javascript,nodejs,odm,mongodb,github,es6"><meta name="description" content="Node.js ODM for MongoDB using ES6 generators."><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="default"><title>Robe</title><link href="https://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic" rel="stylesheet" type="text/css"><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel="stylesheet" type="text/css"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet" type="text/css"><link href="css/style.css" rel="stylesheet" type="text/css"><script src="js/scale.fix.js"></script></head><body><header><h2>Robe<div class="links"><a href="https://github.com/hiddentao/robe" title="Github" class="github"><i class="fa fa-github"></i></a><a href="https://twitter.com/hiddentao" title="Twitter" class="twitter"><i class="fa fa-twitter"></i></a></div></h2><nav></nav></header><main><h1><span>Robe</span><small>Node.js ODM for MongoDB using ES6 generators</small></h1><pre><code class="language-bash">$ npm install --save robe
</code></pre><a href="https://github.com/hiddentao/robe" title="View on Github" class="github"><i class="fa fa-github"></i><span>View on Github</span></a><section id="intro"><p><strong>Robe</strong> wraps around <a href="https://github.com/Automattic/monk">monk</a> to provide a 
simple ODM library for MongoDB. </p>
<p>Overview:</p>
<ul>
<li>ES6 - <strong>no callbacks needed</strong>.</li>
<li>Supports standard Mongo <a href="#querying">query modifiers</a>.</li>
<li>Connect to <a href="#connecting">hosts and replica sets</a>.</li>
<li>Use <a href="#documents">documents</a> or <a href="#raw">raw data</a>, your choice.</li>
<li>Add <a href="#hooks">hooks</a> for further processing.</li>
<li>Stream results using <a href="#cursors">cursors</a>.</li>
<li>Add <a href="#schema">schema validation</a> and <a href="#custom_methods">custom methods</a>.</li>
<li>Notifications via <a href="#oplog">mongo oplog tailing</a>.</li>
<li>Clean, object-oriented <a href="#api">API</a>.</li>
</ul>
<p>To use Robe within your code:</p>
<pre><code class="language-javascript">"use strict";

var Robe = require('robe');
</code></pre></section><section id="connecting"><h2 id="connecting">Connecting</h2>
<p>Robe supports multiple independent database connections:</p>
<pre><code class="language-javascript">var db1 = yield Robe.connect('127.0.0.1'),
  db2 = yield Robe.connect('127.2.1.1');
</code></pre><p>The returned object is an instance of <code>Robe.Database</code>.</p>
<p>Replica sets are also supported:</p>
<pre><code class="language-javascript">var db = yield Robe.connect([
  '127.0.0.1/db-name?replicaSet=test12', 
  '127.2.3.23/db-name?replicaSet=test12'
]);
</code></pre><p>If there is a connection error then the <code>Error</code> object thrown will 
contain a reference to the error returned by the monk connection handler:</p>
<pre><code class="language-javascript">try {
  yield Robe.connect([
    '127.0.0.1/db-name?replicaSet=test12', 
    '127.2.3.23/db-name?replicaSet=test12'
  ]);          
} catch (err) {
  console.log(err.message); /* Failed to connect to db */
  // do something with the error object returned by the native driver.
  console.log(err.root); 
}
</code></pre></section><section id="querying"><h2 id="querying">Querying</h2>
<p>Imagine we have a sample collection - <strong>students</strong> - with the 
following data:</p>
<table><thead><tr><th>_id</th><th>name</th><th>score</th></tr></thead><tr><td>1</td><td>Tom</td><td>19            </td></tr><tr><td>2</td><td>Jim</td><td>22            </td></tr><tr><td>3</td><td>Abe</td><td>98            </td></tr><tr><td>4</td><td>Candy</td><td>5            </td></tr><tr><td>5</td><td>Ram</td><td>27            </td></tr><tr><td>6</td><td>Drew</td><td>41            </td></tr><tr><td>7</td><td>Jeff</td><td>31            </td></tr></table><p>To fetch results:</p>
<pre><code class="language-javascript">var collection = db.collection('students');

var results = yield collection.find({
  // the filtering query (all Mongo modifiers supported)
  score: {
    $gt: 20
  },
}, {
  // only include certain fields in the results
  fields: ['name'],
  // sort results
  sort: { name: 1 },
  // limit no. of results to return
  limit: 3,
  // ignore the first N results
  skip: 1,
});

console.log(
  results.map(function(r) {
    return r.name;
  })
);

/* 'Drew', 'Jeff', 'Ram' */
</code></pre><p>When you only need one result there is a shortcut method you can use:</p>
<pre><code class="language-javascript">var collection = db.collection('students');

var result = yield collection.findOne({
  // the filtering query (all Mongo modifiers supported)
  score: {
    $gt: 20
  },
}, {
  // only include certain fields in the results
  fields: ['name'],
  // sort results
  sort: { name: 1 },
  // ignore the first N results
  skip: 1,
});

console.log(result.name); 

/* 'Drew' */
</code></pre></section><section id="documents"><h3 id="documents">Documents</h3>
<p>Each returned result is an instance of <code>Robe.Document</code>. Documents 
encapsulate the raw data and can be enumerated just like plain 
objects:</p>
<pre><code class="language-javascript">var result = yield collection.findOne({
  // the filtering query (all Mongo modifiers supported)
  score: {
    $gt: 20
  },
}, {
  // only include certain fields in the results
  fields: ['name'],
  // sort results
  sort: { name: 1 },
  // ignore the first N results
  skip: 1,
});

// output the raw data
console.log( result.toJSON() );

/*
  {
    _id: 6,
    name: 'Drew',
    score: 41
  }
 */

// output document keys
console.log( Object.keys(result) );

/*
  '_id', 'name', 'score'
*/

</code></pre><p><code>Robe.Documents</code> instances automatically keep track of which 
properties get changed and only update those properties in the 
database when you call <code>save()</code>.</p>
<pre><code class="language-javascript">var result = yield collection.findOne({
  score: {
    $gt: 20
  },
});

result.name = 'Jimbo';

yield result.save();

/* 
Same as calling:

yield collection.update({_id: result._id}, {
  $set: {
    name: 'Jimbo'
  }
});
*/
</code></pre><p>When setting <code>Array</code> and <code>Object</code> properties of a <code>Robe.Document</code> you 
may need to additionally call the <code>markChanged()</code> method to tell 
Robe that that specific property got updated:</p>
<pre><code class="language-javascript">var result = yield collection.findOne({
  'location.city': 'NYC'
});

result.location.city = 'London';

// we need to tell Robe that the 'location' key got updated
result.markChanged('location');

yield result.save();

/* 
Same as calling:

yield collection.update({_id: result._id}, {
  $set: {
    location: {
      city: 'London'
    }
  }
});
*/
 </code></pre></section><section id="raw"><h3 id="raw-data">Raw data</h3>
<p>If you do wish to deal directly with Mongo data and not use 
<code>Robe.Document</code> instances you can specify the <code>rawMode</code> option:</p>
<pre><code class="language-javascript">var results = yield collection.findOne({
  _id: 1
}, {
  // return Mongo data objects rather than Document instances
  rawMode: true 
});

console.log( result instancoof Robe.Document ); // false

console.log( result );

/*
  {
    _id: 1,
    name: 'Tom',
    score: 19
  }
*/
</code></pre><p>The <code>rawMode</code> option can be specified at the collection level so that 
you don&#39;t have to keep specifying it for every query:</p>
<pre><code class="language-javascript">var collection = db.collection('students', {
  rawMode: true
});

var results = yield collection.findOne({  _id: 1 });

console.log( result instancoof Robe.Document ); // false
</code></pre></section><section id="cursors"><h3 id="cursors-streaming-">Cursors (streaming)</h3>
<p>Sometimes it&#39;s useful to be able to stream data from the database 
one document at a time, especially if we expect the result set to 
be quite large and thus wish to process it bit-by-bit.</p>
<p>Robe can give you an event-driven cursor to facilitate this:</p>
<p><em>Note: At the moment we use an event emitter (and thus, callbacks) when 
working with cursors. We hope to use generators instead in future.</em></p>
<pre><code class="language-javascript">var cursor = yield collection.findStream({  
  score: {
    $gt: 20
  }
}, {
  limit: 3,
  sort: {
    name: -1
  },
  fields: [ 'name' ],
});


cursor.on('result', function(doc) {
  console.log(doc instanceof Robe.Document);  // true
  console.log( doc.toJSON() );
});

cursor.on('error', function(err) {
  console.error(err);
});

cursor.on('success', function() {
  console.log('All done.');
});

/*
  {
    name: 'Tom'                
  }
  {
    name: 'Ram'                
  }
  {
    name: 'Jim'                
  }
  All done.
*/
</code></pre></section><section id="inserting"><h2 id="inserting">Inserting</h2>
<p>Inserting data is done via the <code>Robe.Collection</code> instance:</p>
<pre><code class="language-javascript">var collection = db.collection('students');

var item = yield collection.insert({
  name: 'Amanda',
  score: 76
});

console.log( item instanceof Robe.Document ); // true

console.log( item.toJSON() );

/*
  {
    _id: ...auto-generated mongo id...,
    name: 'Amanda',
    score: 76
  }  
*/
</code></pre><p>Raw insertion mode is also supported:</p>
<pre><code class="language-javascript">var collection = db.collection('students');

var item = yield collection.insert({
  name: 'Amanda',
  score: 76
}, {
  raw: true
});

console.log( item instanceof Robe.Document ); // false

console.log( item );

/*
  {
    _id: ...auto-generated mongo id...,
    name: 'Amanda',
    score: 76
  }  
*/
</code></pre></section><section id="updating"><h2 id="updating">Updating</h2>
<p>Changes made to a <code>Robe.Document</code> can be saved:</p>
<pre><code class="language-javascript">var item = yield collection.findOne({
  _id: 1
});

item.name = 'Martha';

yield item.save();
</code></pre><p>Internally this method calls through to the collection:</p>
<pre><code class="language-javascript">yield collection.update({
  _id: 1  
}, {
  $set: {
    name: 'Martha'
  }
});
</code></pre><p>When calling <code>update()</code> on the collection, ommitting <code>$set</code> will 
cause the entire document to be overriden, just as you would expect:</p>
<pre><code class="language-javascript">yield collection.update({
  _id: 1  
}, {
  name: 'Martha'
});
</code></pre></section><section id="removing"><h2 id="removing">Removing</h2>
<p>Removing a document:</p>
<pre><code class="language-javascript">var item = yield collection.findOne({
  _id: 1
});

yield item.remove();
</code></pre><p>Internally this method calls through to the collection:</p>
<pre><code class="language-javascript">yield collection.remove({
  _id: 1  
});
</code></pre></section><section id="custom_methods"><h2 id="custom-methods">Custom methods</h2>
<p>You can extend <code>Robe.Collection</code> instances with custom querying methods:</p>
<pre><code class="language-javascript">var collection = db.collection('students', {
  methods: {
    // Custom methods must be generator methods.
    findStudentsWithScoreAbove: function*(threshold) {
      // The 'this' context is automatically set to be the Collection instance
      return yield this.find({
        score: {
          $gt: threshold
        }
      }, {
        sort: {
          score: 1
        },
        raw: true
      });
    }
  }
});

yield collection.findStudentsWithScoreAbove(40);

/*
  [
    {
      _id: 3,
      name: 'Abe',
      score: 98
    },
    {
      _id: 6,
      name: 'Drew',
      score: 41
    }
  ]          
*/
</code></pre></section><section id="schema"><h2 id="schema-validation">Schema validation</h2>
<p>Robe will validate the structure of your document against a schema you 
provide:</p>
<pre><code class="language-javascript">var collection = db.collection('students', {
  schema: {
    name: {
      type: String
    },
    score: {
      type: Number,
      required: true
    }
  }
});

yield collection.insert({
  name: 23,
  hasKids: true  
});

/*
  Error: Validation failed
*/
</code></pre><p>The thrown <code>Error</code> instance has a <code>failures</code> key which lists the 
specific validation failures. For the previous example:</p>
<pre><code class="language-javascript">console.log( err.failures );

/*
  [
    "/name: must be a string"
    "/score: missing value"
  ]
*/
</code></pre><p><em>Note: Although <code>hasKids</code> is present in the inserted document, since it 
isn&#39;t present in the schema it gets ignored.</em></p>
<p>Schema validation is done by 
<a href="https://github.com/hiddentao/simple-mongo-schema">simple-mongo-schema</a>,
allowing for nested hierarchies:</p>
<pre><code class="language-javascript">var collection = db.collection('students', {
  schema: {
    name: {
      type: String
    },
    address: {
      type: {
        houseNum: {
          type: Number,
          required: true
        },
        streetName: {
          type: String,
          required: true
        },
        country: {
          type: String,
          required: true
        }
      }
    }
  }
});

try {
  yield collection.insert({
    name: 23,
    address: {
      houseNum: 'view street',
      streetName: 23
    }
  });
} catch (err) {
  console.log(err.failures);

  /*
    [ 
      "/address/houseNum: must be a number",
      "/address/streetName: must be a string",
      "/address/country: missing value",
    ]
  */
}

</code></pre></section><section id="indexes"><h2 id="indexes">Indexes</h2>
<p>Robe supports the full <a href="http://docs.mongodb.org/manual/reference/method/db.collection.ensureIndex/">MongoDB index specification</a>, 
including compound, geospatial and other index types. Specify the 
indexes when fetching a collection:</p>
<pre><code class="language-javascript">var collection = db.collection('students', {
  schema: {
    name: {
      type: String
    },
    score: {
      type: Number,
    }
  },
  indexes: [
    // single-field index, unique
    {
      fields: {
        name: 1
      },
      options: {
        unique: true
      }
    },
    // compount-field index, custom index name
    {
      fields: {
        name: 1,
        score: 1,
      },
      options: {
        name: 'index2'
      }
    }
  ]
});

// Create the indexes if not already present. Throws Error if it fails.
yield collection.ensureIndexes();
</code></pre></section><section id="hooks"><h2 id="hooks">Hooks</h2>
<p>Hooks allow you to perform additional asynchronous processing upon 
data before and/or after all inserts, updates and removals.</p>
<p>You can register hooks against a <code>Robe.Collection</code> instance. 
Hooks get triggered regardless of whether you call methods on the 
collection or perform updates through a <code>Robe.Document</code> instance:</p>
<pre><code class="language-javascript">var collection = db.collection('students');

// run before schema validation and insertion
collection.before('insert', function*(attrs, next) {
  console.log('before');

  attrs.hasKids = true;

  yield next;
});

// run after successful insertion
collection.after('insert', function*(result, next) {
  console.log('after');

  console.log(result);

  yield next;
});

collection.insert({
  name: 'Janice'
});

/*
  before
  after
  {
    _id: ...mongo id...,
    name: 'Janice',
    hasKids: true
  }  
*/
</code></pre><p>Multiple handlers can be registerd for a given hook:</p>
<pre><code class="language-javascript">collection.before('remove', function*(search, next) {
  console.log('before 1');

  search._id += 5;

  yield next;
});

collection.before('remove', function*(search, next) {
  console.log('before 2');

  search._id += 1;

  yield next;
});

collection.before('remove', function*(search, result, next) {
  console.log('after: ' + result);

  console.log(search._id);

  yield next;
});

collection.remove({
  _id: 0
});

/*
  before 1
  before 2
  after: 1
  6
*/
</code></pre><p>For updates you get passed the search query as well as the update 
instructions:</p>
<pre><code class="language-javascript">collection.before('update', function*(search, update, next) {
  console.log('before 1');

  yield next;
});

collection.after('update', function*(search, update, result, next) {
  console.log('after 1');

  yield next;
});

collection.after('update', function*(search, update, result, next) {
  console.log('after 2');

  yield next;
});

collection.update({
  _id: 0
}, {
  $set: {
    name: 'Devon'
  }
});

/*
  before 1
  after 1
  after 2
*/          
</code></pre></section><section id="oplog"><h2 id="oplog-tailing">Oplog tailing</h2>
<p>If you connect to a Mongo replica set then Robe can notify you when 
data within your collections gets updated by your client process or any other.</p>
<p>This can be thought of as a pub/sub mechanism and is used to great 
effect in <em>reactive</em> framworks such as <a href="https://github.com/meteor/meteor/wiki/Oplog-Observe-Driver">Meteor</a>.</p>
<p>To get started:</p>
<pre><code class="language-javascript">var collection = db.collection("students");

// watch for any changes to the collection
yield collection.addWatcher(function(collectionName, operationType, data, metaData) {
  // collectionName = collection which got updated ("student" in this case)
  // operationType = one of: "insert", "update", "delete"
  // data = the data which got inserted or updated (an object)
  // metaData = e.g. the "_id" of the inserted document
});
</code></pre><p>The internal oplog query cursor is not activated until you add a 
watcher. To stop watching for changes:</p>
<pre><code class="language-javascript">var collection = db.collection("students");

var callback = function() { // ... };

// watch for any changes to the collection
yield collection.addWatcher(callback);

// stop watching
yield collection.removeWatcher(callback);
</code></pre><p>You can also access and use the oplog directly through the <code>Database</code> 
object:</p>
<pre><code class="language-javascript">// get the oplog
var oplog = yield db.oplog();

// start it
yield oplog.start();

// listen for any operation on any collection
oplog.onAny(function(collectionName, operationType, data, metaData) {
  // ...
});

// listen for any operation on the "student" collection
oplog.on('student:*', function(collectionName, operationType, data, metaData) {
  // ...
});

// listen for "insert" operations on the "student" collection
oplog.on('student:insert', function(collectionName, operationType, data, metaData) {
  // ...
});
</code></pre><p><em>Note: The current oplog tailing cursor implementation is naive and 
does not take into account how Mongo chooses to populate the oplog. 
Certain bulk operations MAY result in multiple 
notifications being sent to the registered watchers.</em></p>
</section><section id="api"><h2>API</h2></section><footer><p>By <a href="https://twitter.com/hiddentao">@hiddentao</a>. Source on <a href="https://github.coom/hiddentao/robe">Github</a>.</p></footer></main><script type="text/javascript" src="js/prism.js"></script><script type="text/javascript" src="js/jquery.js"></script><script type="text/javascript" src="js/scrollSpy.js"></script><script type="text/javascript" src="js/main.js">     </script></body></html>